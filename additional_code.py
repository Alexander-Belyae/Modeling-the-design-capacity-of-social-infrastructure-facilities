# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wefhauVr1XvW2XkoS1XjuPcWn3OkLwsn
"""

# Установка необходимых библиотек
!pip install geopandas shapely matplotlib seaborn

import geopandas as gpd
import pandas as pd
import numpy as np
from shapely.geometry import Point, Polygon

# Загрузка данных
def load_geodata(file_path):
    """
    Загрузка геопространственных данных.
    """
    return gpd.read_file(file_path)

# Вычисление геометрических характеристик
def compute_geometric_features(gdf):
    """
    Вычисление геометрических характеристик, включая количество вершин.
    """
    # Вычисляем стандартные характеристики
    gdf['area'] = gdf['geometry'].area
    gdf['perimeter'] = gdf['geometry'].length
    gdf['compactness'] = (4 * np.pi * gdf['area']) / (gdf['perimeter'] ** 2)
    gdf['bounding_box'] = gdf['geometry'].apply(lambda x: x.minimum_rotated_rectangle)

    # Длина и ширина
    def calculate_length_and_width(polygon):
        coords = list(polygon.exterior.coords)
        side_lengths = [np.linalg.norm(np.array(coords[i]) - np.array(coords[i - 1])) for i in range(1, len(coords))]
        return max(side_lengths), min(side_lengths)

    gdf[['length', 'width']] = gdf['bounding_box'].apply(
        lambda x: pd.Series(calculate_length_and_width(x))
    )

    # Центроид
    gdf['centroid_x'] = gdf['geometry'].centroid.x
    gdf['centroid_y'] = gdf['geometry'].centroid.y

    # Соотношение площади и периметра
    gdf['area_perimeter_ratio'] = gdf['area'] / gdf['perimeter']

    # Количество вершин
    def count_vertices(geometry):
        if geometry.is_empty or geometry is None:
            return 0
        if geometry.type == 'Polygon':
            return len(geometry.exterior.coords)
        if geometry.type == 'MultiPolygon':
            return sum(len(polygon.exterior.coords) for polygon in geometry.geoms)
        return 0  # Для других типов

    # Применение подсчета
    gdf['vertex_count'] = gdf.geometry.apply(count_vertices)

    # Выпуклая оболочка и коэффициент выпуклости
    gdf['convex_hull'] = gdf['geometry'].convex_hull
    gdf['convex_hull_area'] = gdf['convex_hull'].area
    gdf['convexity_ratio'] = gdf['area'] / gdf['convex_hull_area']

    # Удаляем временные столбцы для экономии памяти
    return gdf.drop(columns=['bounding_box', 'convex_hull'])

# Сохранение данных
def save_data(gdf, output_file_path):
    """
    Сохранение данных в формате GeoJSON.
    """
    gdf.to_file(output_file_path, driver='GeoJSON')

# Основной рабочий процесс
file_path = '/content/schools.geojson'  # Укажите путь к вашему файлу
output_file_path = '/content/schools_processed.geojson'

# Загрузка данных
schools_gdf = load_geodata(file_path)

# Вычисление геометрических характеристик
schools_gdf = compute_geometric_features(schools_gdf)

# Сохранение обработанных данных
save_data(schools_gdf, output_file_path)

print(f"Обработанный файл сохранен как: {output_file_path}")

# Проверка типов геометрий и примеров данных
print(schools_gdf.geometry.head())
print(schools_gdf.geometry.type.value_counts())  # Типы геометрий и их количество
print(schools_gdf.is_empty.sum())  # Количество пустых геометрий
print(schools_gdf.geometry.isna().sum())  # Количество отсутствующих значений

# Функция подсчета вершин
def count_vertices(geometry):
    if geometry.is_empty or geometry is None:
        return 0
    if geometry.type == 'Polygon':
        return len(geometry.exterior.coords)
    if geometry.type == 'MultiPolygon':
        return sum(len(polygon.exterior.coords) for polygon in geometry.geoms)
    return 0  # Для других типов

# Применение подсчета
schools_gdf['vertex_count'] = schools_gdf.geometry.apply(count_vertices)

# Проверяем результат
print(schools_gdf[['geometry', 'vertex_count']].head())

import geopandas as gpd
from sklearn.model_selection import train_test_split

# Путь к файлу с исходными данными
file_path = 'schools_processed.geojson'

# Загрузка файла .geojson
schools_gdf = gpd.read_file(file_path)

# Разделение на тренировочную и тестовую выборки в соотношении 80/20
train_gdf, test_gdf = train_test_split(schools_gdf, test_size=0.2, random_state=42)

# Сохранение тренировочной выборки
train_file_path = 'schools_train.geojson'
train_gdf.to_file(train_file_path, driver='GeoJSON')

# Сохранение тестовой выборки
test_file_path = 'schools_test.geojson'
test_gdf.to_file(test_file_path, driver='GeoJSON')

print(f"Тренировочная выборка сохранена в {train_file_path}")
print(f"Тестовая выборка сохранена в {test_file_path}")